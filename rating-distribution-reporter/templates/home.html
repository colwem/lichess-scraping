<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

    <title>Charts!</title>
  </head>
  <style type="text/css">
  /* 13. Basic Styling with CSS */

  /* Style the lines by removing the fill and applying a stroke */
  .line {
      fill: none;
      stroke-width: 3;
  }

  .overlay {
    fill: none;
    pointer-events: all;
  }

  /* Style the dots by assigning a fill and stroke */
  .dot {
      fill: #ffab00;
      stroke: #fff;
  }

  .focus circle {
    fill: none;
    stroke: steelblue;
  }

  </style>
  <body>
    <div class="container">
      <h1>Charts!</h1>
      <select id="perf-type">
        {% for perf_type in perf_types %}
        <option value="{{perf_type}}"
          {% if perf_type == 'blitz' %}selected='true'{% endif %}>
          {{perf_type | snake_to_title}}
        </option>
        {% endfor %}
      </select>
    </div>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
  <script>


  let dataset = {{data | tojson | safe}};

  let parser = d3.timeParse('%d%m%y%H');
  rootDataset = dataset.map((d) => {
    d.date = parser(d.date);
    return d;
  });

  var selectDataset = (perfType, dataset) => {
    let filtered =  dataset.filter((d) => d.perf_type === perfType);
    filtered.sort((a, b) => a.date - b.date);
    return filtered;
  };

  const arrayMax = (data, negInf, f) => {
    return data.reduce((a, b) => {
      if (a < f(b)){
          return f(b);
        }
        return a;
      }, negInf);
  };

  // 2. Use the margin convention practice
  let container = d3.select("div.container")
  let margin = {top: 50, right: 160, bottom: 50, left: 80}
    , width = container.node().offsetWidth - margin.left - margin.right // Use the window's width
    , height = 600 - margin.top - margin.bottom; // Use the window's height

  // 1. Add the SVG to the page and employ #2
  const svg = d3.select("div.container").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


  let xScale = d3.scaleTime()
    .domain(d3.extent(dataset, (d) => d.date)) // input
    .range([0, width]); // output

  // 6. Y scale will use the randomly generate number
  let yScale = d3.scaleLinear()
      .domain([800, 2800]) // input
      .range([height, 0]); // output

  let rainbow =  d3.scaleSequential(d3.interpolateRdYlBu).domain([0,100]);
  // 3. Call the x axis in a group tag
  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(xScale)); // Create an axis component with d3.axisBottom

// text label for the x axis
  svg.append("text")
      .attr("transform",
            "translate(" + (width/2) + " ," +
                           (height + margin.top) + ")")
      .attr('class', 'axis-label')
      .style("text-anchor", "middle")
      .text("Date");

  // 4. Call the y axis in a group tag
  svg.append("g")
      .attr("class", "y axis")
      .call(d3.axisLeft(yScale).tickFormat(d3.format(''))); // Create an axis component with d3.axisLeft

  svg.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - margin.left)
      .attr("x",0 - (height / 2))
      .attr("dy", "1em")
      .style("text-anchor", "middle")
      .text("Rating");

  // legend
  let percentiles = Object.keys(dataset[0].percentiles)
    .sort((a, b) => b - a)

  let legendScale = d3.scalePoint()
    .domain(percentiles)
    .range([height/2 - 60, height/2 + 60])

  let legend = svg.selectAll('.legend')
    .data(percentiles)

  let legendEnter=legend
        .enter()
        .append('g')
        .attr('class', 'legend')
        .attr('id', d => d + '-p')

  legendEnter
    .append('circle')
        .attr('cx', width +20)
        .attr('cy', d => legendScale(d))
        .attr('r', 7)
        .style('fill', d => rainbow(d));

  legendEnter
    .append('text')
        .attr('x', width+35)
        .attr('y', d => legendScale(d))
        .text(d => d + "th");


  // 7. d3's line generator
  let lines = Object.keys(dataset[0].percentiles).map((key) => {
    return {
      key: key,
      line: d3.line()
        // set the x values for the line generator
        .x(function(d) { return xScale(d.date); })
        // set the y values for the line generator
        .y(function(d) { return yScale(d.percentiles[key]); })
        }});


  // 9. Append the path, bind the data, and call the line generator
  initialPerfType = d3.select('#perf-type').property('value')
  initialDataset = selectDataset(initialPerfType, rootDataset)
  lines.forEach((line) => {
    svg.append("path")
        .datum(initialDataset) // 10. Binds data to the line
        .attr("class", "line") // Assign a class for styling
        .style("stroke", rainbow(line.key))
        .attr('data-percentile', line.key)
        .attr("d", line.line); // 11. Calls the line generator
  });

  const update = (perfType) => {
    let dataset = selectDataset(perfType, rootDataset)
    maxVal = arrayMax(dataset, 0, (d) => {
      return arrayMax(Object.values(d.percentiles), 0, v => v)
    });

    // 5. X scale will use the index of our data
    let lineElements = svg.selectAll('.line')
    lineElements.each(function(d, i) {
        el = d3.select(this)
        let key = el.attr('data-percentile')
        line = lines.find((l) => l.key === key).line
        el.datum(dataset)
          .transition()
          .attr('d', line)

      })


  };

//  // 12. Appends a circle for each datapoint
//  svg.selectAll(".dot")
//      .data(dataset)
//    .enter().append("circle") // Uses the enter().append() method
//      .attr("class", "dot") // Assign a class for styling
//      .attr("cx", function(d) { return xScale(d.date) })
//      .attr("cy", function(d) { return yScale(d.val) })
//      .attr("r", 5)
//        .on("mouseover", function(a, b, c) {
//                          console.log(a)
//          this.attr('class', 'focus')
//                  })
//        .on("mouseout", function() {  })

  d3.select('#perf-type')
  .on('change', function() {
    update(d3.select(this).property('value'));
  });

  //       .on("mousemove", mousemove);

  //   var focus = svg.append("g")
  //       .attr("class", "focus")
  //       .style("display", "none");

  //   focus.append("circle")
  //       .attr("r", 4.5);

  //   focus.append("text")
  //       .attr("x", 9)
  //       .attr("dy", ".35em");

  //   svg.append("rect")
  //       .attr("class", "overlay")
  //       .attr("width", width)
  //       .attr("height", height)
  //       .on("mouseover", function() { focus.style("display", null); })
  //       .on("mouseout", function() { focus.style("display", "none"); })
  //       .on("mousemove", mousemove);

  //   function mousemove() {
  //     var x0 = x.invert(d3.mouse(this)[0]),
  //         i = bisectDate(data, x0, 1),
  //         d0 = data[i - 1],
  //         d1 = data[i],
  //         d = x0 - d0.date > d1.date - x0 ? d1 : d0;
  //     focus.attr("transform", "translate(" + x(d.date) + "," + y(d.close) + ")");
  //     focus.select("text").text(d);
  //   }
  </script>
  </body>
</html>
